// #include <SDL2/SDL.h>
// #include <SDL2/SDL_image.h>
// #include <SDL2/SDL_mixer.h>
// #include <SDL2/SDL_ttf.h>
// #include <iostream>
// #include <vector>
// #include <random>
// #include <string>
// #include <algorithm> // Đã thêm thư viện này

// // Định nghĩa các hằng số
// const int SCREEN_WIDTH = 1500;
// const int SCREEN_HEIGHT = 1000;
// const int PLAYER_SIZE = 50;
// const int ENEMY_SIZE = 40;
// const int BULLET_SIZE = 10;
// const int FONT_SIZE = 24;
// const int ENEMY_SPAWN_RATE = 800;
// const int PLAYER_SPEED = 3;
// const int BULLET_SPEED = 5;
// const int ENEMY_SPEED = 1;

// enum GameState {
//     MENU,
//     PLAYING,
//     GAME_OVER
// };

// struct GameObject {
//     SDL_Rect rect;
//     SDL_Texture* texture;
//     bool is_alive = true;
// };

// // Khai báo các hàm
// SDL_Texture* loadTexture(const char* path, SDL_Renderer* renderer);
// void renderText(SDL_Renderer* renderer, TTF_Font* font, const std::string& text, int x, int y, SDL_Color color);
// SDL_Rect createRandomRect(int width, int height);

// int main(int argc, char* argv[]) {
//     // Khởi tạo SDL
//     if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) < 0) {
//         std::cerr << "SDL không thể khởi tạo! Lỗi: " << SDL_GetError() << std::endl;
//         return 1;
//     }
//     // Khởi tạo SDL_image
//     if (!(IMG_Init(IMG_INIT_PNG) & IMG_INIT_PNG)) {
//         std::cerr << "Không thể khởi tạo SDL_image! Lỗi: " << IMG_GetError() << std::endl;
//         return 1;
//     }
//     // Khởi tạo SDL_mixer
//     if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
//         std::cerr << "Không thể khởi tạo SDL_mixer! Lỗi: " << Mix_GetError() << std::endl;
//         return 1;
//     }
//     // Khởi tạo SDL_ttf
//     if (TTF_Init() < 0) {
//         std::cerr << "Không thể khởi tạo SDL_ttf! Lỗi: " << TTF_GetError() << std::endl;
//         return 1;
//     }

//     // Tạo cửa sổ và renderer
//     SDL_Window* window = SDL_CreateWindow("Game Chiến Đấu", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);
//     SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);

//     // Tải tài nguyên
//     SDL_Texture* background = loadTexture("background.png", renderer);
//     SDL_Texture* playerTexture = loadTexture("player.png", renderer);
//     SDL_Texture* enemyTexture = loadTexture("enemy.png", renderer);
//     SDL_Texture* bulletTexture = loadTexture("bullet.png", renderer);
//     Mix_Chunk* explodeSound = Mix_LoadWAV("explode.wav");
//     TTF_Font* font = TTF_OpenFont("font.ttf", FONT_SIZE);

//     // Khai báo trạng thái game và các biến
//     GameState currentState = MENU;
//     GameObject player;
//     std::vector<GameObject> enemies;
//     std::vector<GameObject> bullets;
//     int score = 0;
//     int enemySpawnCounter = 0;

//     bool running = true;
//     SDL_Event event;

//     while (running) {
//         while (SDL_PollEvent(&event)) {
//             if (event.type == SDL_QUIT) {
//                 running = false;
//             }
//             if (currentState == MENU) {
//                 if (event.type == SDL_MOUSEBUTTONDOWN) {
//                     int mouseX, mouseY;
//                     SDL_GetMouseState(&mouseX, &mouseY);
//                     SDL_Rect startButton = {SCREEN_WIDTH / 2 - 100, SCREEN_HEIGHT / 2 - 25, 200, 50};
//                     SDL_Rect quitButton = {SCREEN_WIDTH / 2 - 100, SCREEN_HEIGHT / 2 + 50, 200, 50};
                    
//                     // Đã sửa lỗi: tạo biến SDL_Point để tránh lỗi rvalue
//                     SDL_Point mousePoint = {mouseX, mouseY};
//                     if (SDL_PointInRect(&mousePoint, &startButton)) {
//                         currentState = PLAYING;
//                         // Khởi tạo lại game
//                         player = {{SCREEN_WIDTH / 2 - PLAYER_SIZE / 2, SCREEN_HEIGHT - PLAYER_SIZE - 20, PLAYER_SIZE, PLAYER_SIZE}, playerTexture, true};
//                         enemies.clear();
//                         bullets.clear();
//                         score = 0;
//                         enemySpawnCounter = 0;
//                     } else if (SDL_PointInRect(&mousePoint, &quitButton)) {
//                         running = false;
//                     }
//                 }
//             } else if (currentState == PLAYING) {
//                 if (event.type == SDL_KEYDOWN) {
//                     if (event.key.keysym.sym == SDLK_SPACE) {
//                         bullets.push_back({{player.rect.x + player.rect.w / 2 - BULLET_SIZE / 2, player.rect.y, BULLET_SIZE, BULLET_SIZE}, bulletTexture, true});
//                     }
//                 }
//             }
//         }

//         // Cập nhật trạng thái game
//         if (currentState == PLAYING) {
//             // Di chuyển player
//             const Uint8* state = SDL_GetKeyboardState(NULL);
//             if (state[SDL_SCANCODE_LEFT]) player.rect.x -= PLAYER_SPEED;
//             if (state[SDL_SCANCODE_RIGHT]) player.rect.x += PLAYER_SPEED;

//             // Giới hạn di chuyển của player
//             if (player.rect.x < 0) player.rect.x = 0;
//             if (player.rect.x + player.rect.w > SCREEN_WIDTH) player.rect.x = SCREEN_WIDTH - player.rect.w;

//             // Di chuyển kẻ địch
//             for (auto& enemy : enemies) {
//                 enemy.rect.y += ENEMY_SPEED;
//             }
            
//             // Di chuyển đạn
//             for (auto& bullet : bullets) {
//                 bullet.rect.y -= BULLET_SPEED;
//             }

//             // Kiểm tra va chạm giữa đạn và kẻ địch
//             for (auto& bullet : bullets) {
//                 for (auto& enemy : enemies) {
//                     if (bullet.is_alive && enemy.is_alive && SDL_HasIntersection(&bullet.rect, &enemy.rect)) {
//                         bullet.is_alive = false;
//                         enemy.is_alive = false;
//                         score++;
//                         if (explodeSound) {
//                             Mix_PlayChannel(-1, explodeSound, 0);
//                         }
//                     }
//                 }
//             }

//             // Kiểm tra va chạm giữa player và kẻ địch
//             for (auto& enemy : enemies) {
//                 if (enemy.is_alive && SDL_HasIntersection(&player.rect, &enemy.rect)) {
//                     currentState = GAME_OVER;
//                 }
//             }

//             // Xóa các vật thể đã bị tiêu diệt hoặc ra khỏi màn hình
//             bullets.erase(std::remove_if(bullets.begin(), bullets.end(), [](const GameObject& obj){ return !obj.is_alive || obj.rect.y < 0; }), bullets.end());
//             enemies.erase(std::remove_if(enemies.begin(), enemies.end(), [](const GameObject& obj){ return !obj.is_alive || obj.rect.y > SCREEN_HEIGHT; }), enemies.end());

//             // Spawn kẻ địch mới
//             enemySpawnCounter++;
//             if (enemySpawnCounter >= ENEMY_SPAWN_RATE) {
//                 enemies.push_back({{createRandomRect(ENEMY_SIZE, ENEMY_SIZE).x, 0, ENEMY_SIZE, ENEMY_SIZE}, enemyTexture, true});
//                 enemySpawnCounter = 0;
//             }
//         }

//         // Vẽ màn hình
//         SDL_RenderClear(renderer);
//         if (background) {
//             SDL_RenderCopy(renderer, background, nullptr, nullptr);
//         } else {
//             SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
//             SDL_RenderFillRect(renderer, nullptr);
//         }

//         if (currentState == MENU) {
//             SDL_Color textColor = {255, 255, 255, 255};
//             renderText(renderer, font, "GAME CHIEN DAU", SCREEN_WIDTH / 2 - 100, SCREEN_HEIGHT / 2 - 100, textColor);
//             renderText(renderer, font, "START", SCREEN_WIDTH / 2 - 50, SCREEN_HEIGHT / 2, textColor);
//             renderText(renderer, font, "QUIT", SCREEN_WIDTH / 2 - 40, SCREEN_HEIGHT / 2 + 75, textColor);
//         } else if (currentState == PLAYING) {
//             // Vẽ các vật thể
//             SDL_RenderCopy(renderer, player.texture, nullptr, &player.rect);
//             for (const auto& enemy : enemies) {
//                 if (enemy.is_alive) {
//                     SDL_RenderCopy(renderer, enemy.texture, nullptr, &enemy.rect);
//                 }
//             }
//             for (const auto& bullet : bullets) {
//                 if (bullet.is_alive) {
//                     SDL_RenderCopy(renderer, bullet.texture, nullptr, &bullet.rect);
//                 }
//             }
            
//             // Vẽ điểm số
//             SDL_Color textColor = {255, 255, 255, 255};
//             renderText(renderer, font, "Diem: " + std::to_string(score), 10, 10, textColor);
//         } else if (currentState == GAME_OVER) {
//             SDL_Color textColor = {255, 255, 255, 255};
//             renderText(renderer, font, "GAME OVER", SCREEN_WIDTH / 2 - 100, SCREEN_HEIGHT / 2 - 50, textColor);
//             renderText(renderer, font, "Diem cua ban: " + std::to_string(score), SCREEN_WIDTH / 2 - 100, SCREEN_HEIGHT / 2, textColor);
//         }
        
//         SDL_RenderPresent(renderer);
//     }

//     // Dọn dẹp
//     SDL_DestroyTexture(background);
//     SDL_DestroyTexture(playerTexture);
//     SDL_DestroyTexture(enemyTexture);
//     SDL_DestroyTexture(bulletTexture);
//     if (explodeSound) Mix_FreeChunk(explodeSound);
//     if (font) TTF_CloseFont(font);
//     IMG_Quit();
//     Mix_CloseAudio();
//     TTF_Quit();
//     SDL_DestroyRenderer(renderer);
//     SDL_DestroyWindow(window);
//     SDL_Quit();

//     return 0;
// }

// // Định nghĩa các hàm phụ trợ
// SDL_Texture* loadTexture(const char* path, SDL_Renderer* renderer) {
//     SDL_Texture* newTexture = IMG_LoadTexture(renderer, path);
//     if (newTexture == nullptr) {
//         std::cerr << "Không thể tải ảnh từ đường dẫn " << path << "! Lỗi SDL_image: " << IMG_GetError() << std::endl;
//     }
//     return newTexture;
// }

// void renderText(SDL_Renderer* renderer, TTF_Font* font, const std::string& text, int x, int y, SDL_Color color) {
//     SDL_Surface* surface = TTF_RenderText_Solid(font, text.c_str(), color);
//     if (surface == nullptr) return;
//     SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
//     if (texture == nullptr) {
//         SDL_FreeSurface(surface);
//         return;
//     }
//     SDL_Rect rect = {x, y, surface->w, surface->h};
//     SDL_RenderCopy(renderer, texture, nullptr, &rect);
//     SDL_FreeSurface(surface);
//     SDL_DestroyTexture(texture);
// }

// SDL_Rect createRandomRect(int width, int height) {
//     std::random_device rd;
//     std::mt19937 gen(rd());
//     std::uniform_int_distribution<> x_dist(0, SCREEN_WIDTH - width);
//     return {x_dist(gen), 0, width, height};
// }





#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>
#include <SDL2/SDL_ttf.h>
#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>

// Global constants for game settings
const int SCREEN_WIDTH = 800;
const int SCREEN_HEIGHT = 600;
const int TILE_SIZE = 40;
const int MAP_WIDTH = 50;
const int MAP_HEIGHT = 50;
const int UI_HEIGHT = 100;
const int DAY_DURATION_MS = 10000;

// Path for the save file
const std::string SAVE_FILE_PATH = "savegame.dat";

// --- Enums for game objects ---
enum TileType {
    GRASS,
    DIRT,
    PLANTED_CROP,
    HAS_ANIMAL
};

enum CropType {
    NO_CROP,
    WHEAT,
    CORN
};

enum AnimalType {
    NO_ANIMAL,
    COW
};

// --- Crop Base Class (Inheritance & Polymorphism) ---
class Crop {
public:
    CropType cropType;
    int days_to_grow;
    int days_to_harvest;
    int harvest_value;
    
    // Virtual destructor is important for polymorphic classes
    virtual ~Crop() {}

    // Virtual methods for polymorphism
    virtual void updateGrowth() = 0;
    virtual bool isGrown() = 0;
    virtual SDL_Texture* getTexture(SDL_Renderer* renderer) = 0;
    virtual void saveState(std::ofstream& file) = 0;
    virtual void loadState(std::ifstream& file) = 0;
};

// --- WheatCrop Derived Class ---
class WheatCrop : public Crop {
private:
    SDL_Texture* texture_planted;
    SDL_Texture* texture_grown;
public:
    WheatCrop(SDL_Texture* planted, SDL_Texture* grown) {
        cropType = WHEAT;
        days_to_grow = 0;
        days_to_harvest = 3;
        harvest_value = 20;
        texture_planted = planted;
        texture_grown = grown;
    }

    ~WheatCrop() override {}

    void updateGrowth() override {
        days_to_grow++;
    }

    bool isGrown() override {
        return days_to_grow >= days_to_harvest;
    }

    SDL_Texture* getTexture(SDL_Renderer* renderer) override {
        if (isGrown()) {
            return texture_grown;
        }
        return texture_planted;
    }
    
    void saveState(std::ofstream& file) override {
        file.write(reinterpret_cast<const char*>(&days_to_grow), sizeof(int));
    }
    
    void loadState(std::ifstream& file) override {
        file.read(reinterpret_cast<char*>(&days_to_grow), sizeof(int));
    }
};

// --- CornCrop Derived Class ---
class CornCrop : public Crop {
private:
    SDL_Texture* texture_planted;
    SDL_Texture* texture_grown;
public:
    CornCrop(SDL_Texture* planted, SDL_Texture* grown) {
        cropType = CORN;
        days_to_grow = 0;
        days_to_harvest = 5;
        harvest_value = 40;
        texture_planted = planted;
        texture_grown = grown;
    }
    
    ~CornCrop() override {}
    
    void updateGrowth() override {
        days_to_grow++;
    }
    
    bool isGrown() override {
        return days_to_grow >= days_to_harvest;
    }
    
    SDL_Texture* getTexture(SDL_Renderer* renderer) override {
        if (isGrown()) {
            return texture_grown;
        }
        return texture_planted;
    }

    void saveState(std::ofstream& file) override {
        file.write(reinterpret_cast<const char*>(&days_to_grow), sizeof(int));
    }
    
    void loadState(std::ifstream& file) override {
        file.read(reinterpret_cast<char*>(&days_to_grow), sizeof(int));
    }
};

// --- Animal Base Class (Inheritance & Polymorphism) ---
class Animal {
public:
    AnimalType animalType;
    int days_until_harvest;
    int harvest_value;
    
    virtual ~Animal() {}
    
    virtual void update() = 0;
    virtual bool isReadyToHarvest() = 0;
    virtual SDL_Texture* getTexture() = 0;
    virtual void saveState(std::ofstream& file) = 0;
    virtual void loadState(std::ifstream& file) = 0;
    virtual void reset() = 0;
};

// --- Cow Derived Class ---
class Cow : public Animal {
private:
    SDL_Texture* texture;
public:
    Cow(SDL_Texture* cow_texture) {
        animalType = COW;
        days_until_harvest = 0;
        harvest_value = 50;
        texture = cow_texture;
    }
    
    ~Cow() override {}
    
    void update() override {
        days_until_harvest++;
    }
    
    bool isReadyToHarvest() override {
        return days_until_harvest >= 5;
    }
    
    SDL_Texture* getTexture() override {
        return texture;
    }
    
    void reset() override {
        days_until_harvest = 0;
    }
    
    void saveState(std::ofstream& file) override {
        file.write(reinterpret_cast<const char*>(&days_until_harvest), sizeof(int));
    }
    
    void loadState(std::ifstream& file) override {
        file.read(reinterpret_cast<char*>(&days_until_harvest), sizeof(int));
    }
};

// --- Player Class ---
class Player {
public:
    int money;
    int wheat_seed_count;
    int corn_seed_count;
    int cow_count;

    Player() : money(50), wheat_seed_count(5), corn_seed_count(0), cow_count(0) {}
};

// --- Tile Class ---
class Tile {
public:
    TileType type;
    Crop* crop;
    Animal* animal;

    Tile() : type(GRASS), crop(nullptr), animal(nullptr) {}
    ~Tile() {
        if (crop) {
            delete crop;
        }
        if (animal) {
            delete animal;
        }
    }
};

// --- Game Class ---
class Game {
private:
    SDL_Window* window;
    SDL_Renderer* renderer;
    TTF_Font* font;
    Player player;
    std::vector<std::vector<Tile>> farm_map;
    int current_day;
    Uint32 last_day_update;

    int cameraX;
    int cameraY;
    bool isPanning;
    int mouseStartX, mouseStartY;

    // Textures - All textures are loaded once here for performance
    SDL_Texture* grassTexture;
    SDL_Texture* dirtTexture;
    SDL_Texture* wheatPlantedTexture;
    SDL_Texture* wheatGrownTexture;
    SDL_Texture* cornPlantedTexture;
    SDL_Texture* cornGrownTexture;
    SDL_Texture* cowTexture;
    
public:
    Game() : window(nullptr), renderer(nullptr), font(nullptr), current_day(1), last_day_update(0), cameraX(0), cameraY(0), isPanning(false) {
        farm_map.resize(MAP_HEIGHT, std::vector<Tile>(MAP_WIDTH));
    }

    bool init() {
        if (SDL_Init(SDL_INIT_VIDEO) < 0 || !(IMG_Init(IMG_INIT_PNG) & IMG_INIT_PNG) || TTF_Init() < 0) {
            std::cerr << "Initialization failed!" << std::endl;
            return false;
        }

        window = SDL_CreateWindow("Farm Manager PBL", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);
        renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
        if (!window || !renderer) {
            std::cerr << "Window or Renderer creation failed!" << std::endl;
            return false;
        }

        // Load all textures ONCE at the start for better performance
        grassTexture = IMG_LoadTexture(renderer, "grass.png");
        dirtTexture = IMG_LoadTexture(renderer, "dirt.png");
        wheatPlantedTexture = IMG_LoadTexture(renderer, "planted.png");
        wheatGrownTexture = IMG_LoadTexture(renderer, "grown.png");
        cornPlantedTexture = IMG_LoadTexture(renderer, "corn_planted.png");
        cornGrownTexture = IMG_LoadTexture(renderer, "corn_grown.png");
        cowTexture = IMG_LoadTexture(renderer, "cow.png");
        font = TTF_OpenFont("font.ttf", 24);

        
        loadGame();
        last_day_update = SDL_GetTicks();
        return true;
    }

    void run() {
        bool running = true;
        SDL_Event event;

        while (running) {
            while (SDL_PollEvent(&event)) {
                if (event.type == SDL_QUIT) {
                    running = false;
                }
                if (event.type == SDL_MOUSEBUTTONDOWN) {
                    handleMouseClick(event);
                }
                if (event.type == SDL_MOUSEBUTTONUP) {
                    handleMouseUp(event);
                }
                if (event.type == SDL_MOUSEMOTION) {
                    handleMouseMotion(event);
                }
            }
            update();
            render();
        }
        saveGame();
    }

    void close() {
        if (grassTexture) SDL_DestroyTexture(grassTexture);
        if (dirtTexture) SDL_DestroyTexture(dirtTexture);
        if (wheatPlantedTexture) SDL_DestroyTexture(wheatPlantedTexture);
        if (wheatGrownTexture) SDL_DestroyTexture(wheatGrownTexture);
        if (cornPlantedTexture) SDL_DestroyTexture(cornPlantedTexture);
        if (cornGrownTexture) SDL_DestroyTexture(cornGrownTexture);
        if (cowTexture) SDL_DestroyTexture(cowTexture);
        if (font) TTF_CloseFont(font);
        IMG_Quit();
        TTF_Quit();
        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        SDL_Quit();
    }

private:
    void renderText(const std::string& text, int x, int y, SDL_Color color) {
        if (!font) return;
        SDL_Surface* textSurface = TTF_RenderText_Solid(font, text.c_str(), color);
        if (!textSurface) return;
        SDL_Texture* textTexture = SDL_CreateTextureFromSurface(renderer, textSurface);
        if (!textTexture) {
            SDL_FreeSurface(textSurface);
            return;
        }
        SDL_Rect renderQuad = {x, y, textSurface->w, textSurface->h};
        SDL_RenderCopy(renderer, textTexture, NULL, &renderQuad);
        SDL_FreeSurface(textSurface);
        SDL_DestroyTexture(textTexture);
    }
    
    void saveGame() {
        std::ofstream file(SAVE_FILE_PATH, std::ios::out | std::ios::binary);
        if (file.is_open()) {
            file.write(reinterpret_cast<char*>(&player), sizeof(Player));
            file.write(reinterpret_cast<char*>(&current_day), sizeof(int));
            
            for (const auto& row : farm_map) {
                for (const auto& tile : row) {
                    file.write(reinterpret_cast<const char*>(&tile.type), sizeof(TileType));
                    if (tile.type == PLANTED_CROP) {
                        file.write(reinterpret_cast<const char*>(&tile.crop->cropType), sizeof(CropType));
                        tile.crop->saveState(file);
                    } else if (tile.type == HAS_ANIMAL) {
                        file.write(reinterpret_cast<const char*>(&tile.animal->animalType), sizeof(AnimalType));
                        tile.animal->saveState(file);
                    }
                }
            }
            file.close();
            std::cout << "Game saved successfully!" << std::endl;
        } else {
            std::cerr << "Could not save game file!" << std::endl;
        }
    }

    void loadGame() {
        std::ifstream file(SAVE_FILE_PATH, std::ios::in | std::ios::binary);
        if (file.is_open()) {
            file.read(reinterpret_cast<char*>(&player), sizeof(Player));
            file.read(reinterpret_cast<char*>(&current_day), sizeof(int));

            for (auto& row : farm_map) {
                for (auto& tile : row) {
                    if (tile.crop) { delete tile.crop; tile.crop = nullptr; }
                    if (tile.animal) { delete tile.animal; tile.animal = nullptr; }
                    
                    file.read(reinterpret_cast<char*>(&tile.type), sizeof(TileType));
                    if (tile.type == PLANTED_CROP) {
                        CropType cropType;
                        file.read(reinterpret_cast<char*>(&cropType), sizeof(CropType));
                        if (cropType == WHEAT) {
                            tile.crop = new WheatCrop(wheatPlantedTexture, wheatGrownTexture);
                        } else if (cropType == CORN) {
                            tile.crop = new CornCrop(cornPlantedTexture, cornGrownTexture);
                        }
                        if (tile.crop) {
                            tile.crop->loadState(file);
                        }
                    } else if (tile.type == HAS_ANIMAL) {
                        AnimalType animalType;
                        file.read(reinterpret_cast<char*>(&animalType), sizeof(AnimalType));
                        if (animalType == COW) {
                            tile.animal = new Cow(cowTexture);
                        }
                        if (tile.animal) {
                            tile.animal->loadState(file);
                        }
                    }
                }
            }
            file.close();
            std::cout << "Game loaded successfully!" << std::endl;
        } else {
            std::cout << "No save file found. Starting new game." << std::endl;
        }
    }

    void handleMouseClick(SDL_Event& event) {
        if (event.button.button == SDL_BUTTON_RIGHT) {
            isPanning = true;
            SDL_GetMouseState(&mouseStartX, &mouseStartY);
            return;
        }

        if (event.button.button == SDL_BUTTON_LEFT) {
            // Check for UI clicks first
            if (event.button.y >= SCREEN_HEIGHT - UI_HEIGHT) {
                // Check if buy wheat seeds button is clicked
                SDL_Rect wheatBuyButton = {SCREEN_WIDTH - 300, SCREEN_HEIGHT - UI_HEIGHT + 10, 90, 80};
                if (event.button.x >= wheatBuyButton.x && event.button.x < wheatBuyButton.x + wheatBuyButton.w &&
                    event.button.y >= wheatBuyButton.y && event.button.y < wheatBuyButton.y + wheatBuyButton.h) {
                    if (player.money >= 10) {
                        player.money -= 10;
                        player.wheat_seed_count += 5;
                    }
                    return;
                }
                
                // Check if buy corn seeds button is clicked
                SDL_Rect cornBuyButton = {SCREEN_WIDTH - 200, SCREEN_HEIGHT - UI_HEIGHT + 10, 90, 80};
                if (event.button.x >= cornBuyButton.x && event.button.x < cornBuyButton.x + cornBuyButton.w &&
                    event.button.y >= cornBuyButton.y && event.button.y < cornBuyButton.y + cornBuyButton.h) {
                    if (player.money >= 20) {
                        player.money -= 20;
                        player.corn_seed_count += 3;
                    }
                    return;
                }

                // Check if buy cow button is clicked
                SDL_Rect cowBuyButton = {SCREEN_WIDTH - 100, SCREEN_HEIGHT - UI_HEIGHT + 10, 90, 80};
                if (event.button.x >= cowBuyButton.x && event.button.x < cowBuyButton.x + cowBuyButton.w &&
                    event.button.y >= cowBuyButton.y && event.button.y < cowBuyButton.y + cowBuyButton.h) {
                    if (player.money >= 100) {
                        player.money -= 100;
                        player.cow_count++;
                    }
                    return;
                }
            }

            // Handle clicks on the map
            int tileX = (event.button.x + cameraX) / TILE_SIZE;
            int tileY = (event.button.y + cameraY) / TILE_SIZE;
            
            if (tileX >= 0 && tileX < MAP_WIDTH && tileY >= 0 && tileY < MAP_HEIGHT) {
                Tile& clicked_tile = farm_map[tileY][tileX];
                
                if (clicked_tile.type == GRASS) {
                    if (player.money >= 10) {
                        clicked_tile.type = DIRT;
                        player.money -= 10;
                    }
                } else if (clicked_tile.type == DIRT) {
                    // Plant based on seeds available
                    if (player.wheat_seed_count >= 1) {
                        clicked_tile.type = PLANTED_CROP;
                        clicked_tile.crop = new WheatCrop(wheatPlantedTexture, wheatGrownTexture);
                        player.wheat_seed_count -= 1;
                    } else if (player.corn_seed_count >= 1) {
                        clicked_tile.type = PLANTED_CROP;
                        clicked_tile.crop = new CornCrop(cornPlantedTexture, cornGrownTexture);
                        player.corn_seed_count -= 1;
                    } else if (player.cow_count >= 1) {
                        clicked_tile.type = HAS_ANIMAL;
                        clicked_tile.animal = new Cow(cowTexture);
                        player.cow_count--;
                    }
                } else if (clicked_tile.type == PLANTED_CROP && clicked_tile.crop && clicked_tile.crop->isGrown()) {
                    player.money += clicked_tile.crop->harvest_value;
                    delete clicked_tile.crop;
                    clicked_tile.crop = nullptr;
                    clicked_tile.type = DIRT;
                } else if (clicked_tile.type == HAS_ANIMAL && clicked_tile.animal && clicked_tile.animal->isReadyToHarvest()) {
                    player.money += clicked_tile.animal->harvest_value;
                    clicked_tile.animal->reset();
                }
            }
        }
    }
    
    void handleMouseUp(SDL_Event& event) {
        if (event.button.button == SDL_BUTTON_RIGHT) {
            isPanning = false;
        }
    }
    
    void handleMouseMotion(SDL_Event& event) {
        if (isPanning) {
            int currentX, currentY;
            SDL_GetMouseState(&currentX, &currentY);
            
            cameraX -= (currentX - mouseStartX);
            cameraY -= (currentY - mouseStartY);
            
            if (cameraX < 0) cameraX = 0;
            if (cameraY < 0) cameraY = 0;
            if (cameraX > (MAP_WIDTH * TILE_SIZE) - SCREEN_WIDTH) cameraX = (MAP_WIDTH * TILE_SIZE) - SCREEN_WIDTH;
            if (cameraY > (MAP_HEIGHT * TILE_SIZE) - (SCREEN_HEIGHT - UI_HEIGHT)) cameraY = (MAP_HEIGHT * TILE_SIZE) - (SCREEN_HEIGHT - UI_HEIGHT);
            
            mouseStartX = currentX;
            mouseStartY = currentY;
        }
    }

    void update() {
        if (SDL_GetTicks() - last_day_update >= DAY_DURATION_MS) {
            current_day++;
            last_day_update = SDL_GetTicks();
            
            for (int y = 0; y < MAP_HEIGHT; ++y) {
                for (int x = 0; x < MAP_WIDTH; ++x) {
                    Tile& currentTile = farm_map[y][x];
                    if (currentTile.type == PLANTED_CROP && currentTile.crop) {
                        currentTile.crop->updateGrowth();
                    } else if (currentTile.type == HAS_ANIMAL && currentTile.animal) {
                        currentTile.animal->update();
                    }
                }
            }
        }
    }

    void render() {
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderClear(renderer);

        // Hiển thị thông báo lỗi nếu không tải được tài nguyên
        if (!grassTexture || !dirtTexture || !wheatPlantedTexture || !wheatGrownTexture || !cornPlantedTexture || !cornGrownTexture || !cowTexture || !font) {
            SDL_Color red = {255, 0, 0, 255};
            renderText("Loi: Thieu file hinh anh hoac font!", 100, 200, red);
            renderText("Vui long dat cac file sau vao cung thu muc:", 100, 250, red);
            renderText("grass.png, dirt.png, planted.png, grown.png, corn_planted.png, corn_grown.png, cow.png, font.ttf", 100, 280, red);
            SDL_RenderPresent(renderer);
            return;
        }

        for (int y = 0; y < MAP_HEIGHT; ++y) {
            for (int x = 0; x < MAP_WIDTH; ++x) {
                SDL_Rect tileRect = {x * TILE_SIZE - cameraX, y * TILE_SIZE - cameraY, TILE_SIZE, TILE_SIZE};
                
                if (tileRect.x + TILE_SIZE >= 0 && tileRect.x < SCREEN_WIDTH &&
                    tileRect.y + TILE_SIZE >= 0 && tileRect.y < SCREEN_HEIGHT - UI_HEIGHT) {
                    
                    SDL_Texture* currentTexture = nullptr;
                    Tile& currentTile = farm_map[y][x];
                    
                    switch (currentTile.type) {
                        case GRASS: currentTexture = grassTexture; break;
                        case DIRT: currentTexture = dirtTexture; break;
                        case PLANTED_CROP:
                            if (currentTile.crop) {
                                currentTexture = currentTile.crop->getTexture(renderer);
                            }
                            break;
                        case HAS_ANIMAL:
                            if (currentTile.animal) {
                                currentTexture = currentTile.animal->getTexture();
                            }
                            break;
                    }
                    if (currentTexture) {
                        SDL_RenderCopy(renderer, currentTexture, nullptr, &tileRect);
                    }
                }
            }
        }

        // Render UI
        SDL_Rect uiRect = {0, SCREEN_HEIGHT - UI_HEIGHT, SCREEN_WIDTH, UI_HEIGHT};
        SDL_SetRenderDrawColor(renderer, 50, 50, 50, 255);
        SDL_RenderFillRect(renderer, &uiRect);
        
        SDL_Color textColor = {255, 255, 255, 255};
        renderText("Tien: " + std::to_string(player.money), 10, SCREEN_HEIGHT - UI_HEIGHT + 10, textColor);
        renderText("Hat Lua: " + std::to_string(player.wheat_seed_count), 10, SCREEN_HEIGHT - UI_HEIGHT + 40, textColor);
        renderText("Hat Ngo: " + std::to_string(player.corn_seed_count), 10, SCREEN_HEIGHT - UI_HEIGHT + 70, textColor);
        renderText("So luong bo: " + std::to_string(player.cow_count), 250, SCREEN_HEIGHT - UI_HEIGHT + 10, textColor);

        // Render Buy buttons
        // Buy Wheat
        SDL_Rect wheatBuyButton = {SCREEN_WIDTH - 300, SCREEN_HEIGHT - UI_HEIGHT + 10, 90, 80};
        SDL_SetRenderDrawColor(renderer, 100, 200, 100, 255);
        SDL_RenderFillRect(renderer, &wheatBuyButton);
        renderText("Mua Lua", wheatBuyButton.x + 5, wheatBuyButton.y + 10, {0, 0, 0, 255});
        renderText("(10)", wheatBuyButton.x + 25, wheatBuyButton.y + 50, {0, 0, 0, 255});
        
        // Buy Corn
        SDL_Rect cornBuyButton = {SCREEN_WIDTH - 200, SCREEN_HEIGHT - UI_HEIGHT + 10, 90, 80};
        SDL_SetRenderDrawColor(renderer, 100, 150, 200, 255);
        SDL_RenderFillRect(renderer, &cornBuyButton);
        renderText("Mua Ngo", cornBuyButton.x + 5, cornBuyButton.y + 10, {0, 0, 0, 255});
        renderText("(20)", cornBuyButton.x + 25, cornBuyButton.y + 50, {0, 0, 0, 255});

        // Buy Cow
        SDL_Rect cowBuyButton = {SCREEN_WIDTH - 100, SCREEN_HEIGHT - UI_HEIGHT + 10, 90, 80};
        SDL_SetRenderDrawColor(renderer, 200, 150, 100, 255);
        SDL_RenderFillRect(renderer, &cowBuyButton);
        renderText("Mua Bo", cowBuyButton.x + 5, cowBuyButton.y + 10, {0, 0, 0, 255});
        renderText("(100)", cowBuyButton.x + 20, cowBuyButton.y + 50, {0, 0, 0, 255});
        
        SDL_RenderPresent(renderer);
    }
};

int main(int argc, char* argv[]) {
    Game farmGame;

    if (!farmGame.init()) {
        std::cerr << "Failed to initialize game!" << std::endl;
        return 1;
    }

    farmGame.run();
    farmGame.close();

    return 0;
